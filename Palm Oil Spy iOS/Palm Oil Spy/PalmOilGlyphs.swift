//
//  PalmOilGlyphs.swift
//  Palm Oil App
//
//  Created by Vladimír Bělohradský on 19/06/2017.
//  Copyright © 2017 GDGSCL. All rights reserved.
//
//  Generated by PaintCode
//  http://www.paintcodeapp.com
//



import UIKit

public class PalmOilGlyphs : NSObject {

    //// Cache

    private struct Cache {
        static let noOilColor: UIColor = UIColor(red: 0.652, green: 0.800, blue: 0.320, alpha: 1.000)
        static let oilColor: UIColor = UIColor(red: 0.800, green: 0.320, blue: 0.320, alpha: 1.000)
        static var imageOfFeedbackOn: UIImage?
        static var feedbackOnTargets: [AnyObject]?
        static var imageOfFeedbackOff: UIImage?
        static var feedbackOffTargets: [AnyObject]?
    }

    //// Colors

    @objc dynamic public class var noOilColor: UIColor { return Cache.noOilColor }
    @objc dynamic public class var oilColor: UIColor { return Cache.oilColor }

    //// Drawing Methods

    @objc dynamic public class func drawThumbOK(frame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), goodColor: UIColor = UIColor(red: 0.652, green: 0.800, blue: 0.320, alpha: 1.000)) {

        //// Bezier 2 Drawing
        let bezier2Path = UIBezierPath()
        bezier2Path.move(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.50000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.22385 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.22385 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 1.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.77615 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.22389 * frame.width, y: frame.minY + 1.00000 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.50000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.77611 * frame.width, y: frame.minY + 1.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.77615 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.22385 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.77611 * frame.width, y: frame.minY + 0.00000 * frame.height))
        bezier2Path.close()
        bezier2Path.move(to: CGPoint(x: frame.minX + 0.79187 * frame.width, y: frame.minY + 0.36457 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.44958 * frame.width, y: frame.minY + 0.69650 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.42868 * frame.width, y: frame.minY + 0.70494 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.44377 * frame.width, y: frame.minY + 0.70213 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.43622 * frame.width, y: frame.minY + 0.70494 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.40749 * frame.width, y: frame.minY + 0.69617 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.42099 * frame.width, y: frame.minY + 0.70494 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.41334 * frame.width, y: frame.minY + 0.70202 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.27412 * frame.width, y: frame.minY + 0.56280 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.27412 * frame.width, y: frame.minY + 0.52037 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.26242 * frame.width, y: frame.minY + 0.55110 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.26242 * frame.width, y: frame.minY + 0.53211 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.31655 * frame.width, y: frame.minY + 0.52037 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.28583 * frame.width, y: frame.minY + 0.50863 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.30481 * frame.width, y: frame.minY + 0.50867 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.42902 * frame.width, y: frame.minY + 0.63284 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.75011 * frame.width, y: frame.minY + 0.32150 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.79254 * frame.width, y: frame.minY + 0.32218 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.76200 * frame.width, y: frame.minY + 0.30999 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.78095 * frame.width, y: frame.minY + 0.31025 * frame.height))
        bezier2Path.addCurve(to: CGPoint(x: frame.minX + 0.79187 * frame.width, y: frame.minY + 0.36461 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.80406 * frame.width, y: frame.minY + 0.33407 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.80376 * frame.width, y: frame.minY + 0.35305 * frame.height))
        bezier2Path.addLine(to: CGPoint(x: frame.minX + 0.79187 * frame.width, y: frame.minY + 0.36457 * frame.height))
        bezier2Path.close()
        goodColor.setFill()
        bezier2Path.fill()
    }

    @objc dynamic public class func drawThumbKO(frame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), alertColor: UIColor = UIColor(red: 0.800, green: 0.320, blue: 0.320, alpha: 1.000)) {

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.85353 * frame.width, y: frame.minY + 0.14644 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.14645 * frame.width, y: frame.minY + 0.14644 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.65824 * frame.width, y: frame.minY + -0.04881 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.34175 * frame.width, y: frame.minY + -0.04881 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.14645 * frame.width, y: frame.minY + 0.85354 * frame.height), controlPoint1: CGPoint(x: frame.minX + -0.04884 * frame.width, y: frame.minY + 0.34170 * frame.height), controlPoint2: CGPoint(x: frame.minX + -0.04880 * frame.width, y: frame.minY + 0.65824 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.85353 * frame.width, y: frame.minY + 0.85354 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.34171 * frame.width, y: frame.minY + 1.04884 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.65824 * frame.width, y: frame.minY + 1.04880 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.85353 * frame.width, y: frame.minY + 0.14644 * frame.height), controlPoint1: CGPoint(x: frame.minX + 1.04882 * frame.width, y: frame.minY + 0.65824 * frame.height), controlPoint2: CGPoint(x: frame.minX + 1.04882 * frame.width, y: frame.minY + 0.34174 * frame.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.72535 * frame.width, y: frame.minY + 0.69703 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.69707 * frame.width, y: frame.minY + 0.72532 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.50001 * frame.width, y: frame.minY + 0.52826 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.30296 * frame.width, y: frame.minY + 0.72532 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.27467 * frame.width, y: frame.minY + 0.69703 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.47173 * frame.width, y: frame.minY + 0.49997 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.27374 * frame.width, y: frame.minY + 0.30198 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.30202 * frame.width, y: frame.minY + 0.27369 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.50001 * frame.width, y: frame.minY + 0.47169 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.69800 * frame.width, y: frame.minY + 0.27369 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.72629 * frame.width, y: frame.minY + 0.30198 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.52830 * frame.width, y: frame.minY + 0.49997 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.72535 * frame.width, y: frame.minY + 0.69703 * frame.height))
        bezierPath.close()
        alertColor.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawUnknown(frame: CGRect = CGRect(x: 0, y: 0, width: 200, height: 200), borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.00000 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.50000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.22385 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.22385 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 1.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.00000 * frame.width, y: frame.minY + 0.77615 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.22385 * frame.width, y: frame.minY + 1.00000 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.50000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.77615 * frame.width, y: frame.minY + 1.00000 * frame.height), controlPoint2: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.77611 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.00000 * frame.height), controlPoint1: CGPoint(x: frame.minX + 1.00000 * frame.width, y: frame.minY + 0.22385 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.77615 * frame.width, y: frame.minY + 0.00000 * frame.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.76002 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.46001 * frame.width, y: frame.minY + 0.72003 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.47794 * frame.width, y: frame.minY + 0.76002 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.46001 * frame.width, y: frame.minY + 0.74212 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.68003 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.46001 * frame.width, y: frame.minY + 0.69797 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.47794 * frame.width, y: frame.minY + 0.68003 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.53999 * frame.width, y: frame.minY + 0.72003 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.52206 * frame.width, y: frame.minY + 0.68003 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.53999 * frame.width, y: frame.minY + 0.69793 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 0.76002 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.53999 * frame.width, y: frame.minY + 0.74212 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.52210 * frame.width, y: frame.minY + 0.76002 * frame.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: frame.minX + 0.57949 * frame.width, y: frame.minY + 0.48638 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.52468 * frame.width, y: frame.minY + 0.59998 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.52596 * frame.width, y: frame.minY + 0.53992 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.52731 * frame.width, y: frame.minY + 0.53868 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.48000 * frame.width, y: frame.minY + 0.59998 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.55080 * frame.width, y: frame.minY + 0.45975 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.48267 * frame.width, y: frame.minY + 0.53234 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.49760 * frame.width, y: frame.minY + 0.50915 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.59630 * frame.width, y: frame.minY + 0.36945 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.57668 * frame.width, y: frame.minY + 0.43525 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.59630 * frame.width, y: frame.minY + 0.40584 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.49621 * frame.width, y: frame.minY + 0.27495 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.59630 * frame.width, y: frame.minY + 0.31344 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.55080 * frame.width, y: frame.minY + 0.27495 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.38348 * frame.width, y: frame.minY + 0.39998 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.41991 * frame.width, y: frame.minY + 0.27495 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.38209 * frame.width, y: frame.minY + 0.32784 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.33936 * frame.width, y: frame.minY + 0.39998 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.49827 * frame.width, y: frame.minY + 0.23785 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.34007 * frame.width, y: frame.minY + 0.30061 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.39676 * frame.width, y: frame.minY + 0.23785 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.64034 * frame.width, y: frame.minY + 0.36735 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.57593 * frame.width, y: frame.minY + 0.23785 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.64034 * frame.width, y: frame.minY + 0.28616 * frame.height))
        bezierPath.addCurve(to: CGPoint(x: frame.minX + 0.57946 * frame.width, y: frame.minY + 0.48638 * frame.height), controlPoint1: CGPoint(x: frame.minX + 0.64034 * frame.width, y: frame.minY + 0.41916 * frame.height), controlPoint2: CGPoint(x: frame.minX + 0.61513 * frame.width, y: frame.minY + 0.45277 * frame.height))
        bezierPath.addLine(to: CGPoint(x: frame.minX + 0.57949 * frame.width, y: frame.minY + 0.48638 * frame.height))
        bezierPath.close()
        borderColor.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawFlashlightOff(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32), resizing: ResizingBehavior = .aspectFit, borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 32, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 32, y: resizedFrame.height / 32)


        //// icomoon-ignore


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 18.73, y: 3.77))
        bezierPath.addLine(to: CGPoint(x: 17.35, y: 14.93))
        bezierPath.addLine(to: CGPoint(x: 23.44, y: 14.93))
        bezierPath.addLine(to: CGPoint(x: 13.27, y: 28.23))
        bezierPath.addLine(to: CGPoint(x: 14.65, y: 17.07))
        bezierPath.addLine(to: CGPoint(x: 8.56, y: 17.07))
        bezierPath.addLine(to: CGPoint(x: 18.73, y: 3.77))
        bezierPath.addLine(to: CGPoint(x: 18.73, y: 3.77))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 20.27, y: 0.01))
        bezierPath.addLine(to: CGPoint(x: 6.4, y: 18.13))
        bezierPath.addLine(to: CGPoint(x: 13.44, y: 18.13))
        bezierPath.addLine(to: CGPoint(x: 11.73, y: 31.99))
        bezierPath.addLine(to: CGPoint(x: 25.6, y: 13.87))
        bezierPath.addLine(to: CGPoint(x: 18.56, y: 13.87))
        bezierPath.addLine(to: CGPoint(x: 20.27, y: 0.01))
        bezierPath.close()
        borderColor.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawFlashlightOn(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32), resizing: ResizingBehavior = .aspectFit, borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 32, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 32, y: resizedFrame.height / 32)


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 25.6, y: 13.87))
        bezierPath.addLine(to: CGPoint(x: 18.56, y: 13.87))
        bezierPath.addLine(to: CGPoint(x: 20.27, y: 0.01))
        bezierPath.addLine(to: CGPoint(x: 6.4, y: 18.13))
        bezierPath.addLine(to: CGPoint(x: 13.44, y: 18.13))
        bezierPath.addLine(to: CGPoint(x: 11.73, y: 31.99))
        bezierPath.addLine(to: CGPoint(x: 25.6, y: 13.87))
        bezierPath.close()
        borderColor.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawSoundsOff(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 31, height: 32), resizing: ResizingBehavior = .aspectFit, borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 31, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 31, y: resizedFrame.height / 32)


        //// Bezier 3 Drawing
        let bezier3Path = UIBezierPath()
        bezier3Path.move(to: CGPoint(x: 27.3, y: 4.59))
        bezier3Path.addLine(to: CGPoint(x: 26.56, y: 3.85))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 10.99))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 5.17))
        bezier3Path.addLine(to: CGPoint(x: 11.73, y: 11.3))
        bezier3Path.addLine(to: CGPoint(x: 5.78, y: 11.3))
        bezier3Path.addLine(to: CGPoint(x: 5.78, y: 16.04))
        bezier3Path.addLine(to: CGPoint(x: 5.78, y: 16.04))
        bezier3Path.addLine(to: CGPoint(x: 5.78, y: 16.05))
        bezier3Path.addLine(to: CGPoint(x: 5.78, y: 20.74))
        bezier3Path.addLine(to: CGPoint(x: 9.67, y: 20.74))
        bezier3Path.addLine(to: CGPoint(x: 3, y: 27.41))
        bezier3Path.addLine(to: CGPoint(x: 3.74, y: 28.15))
        bezier3Path.addLine(to: CGPoint(x: 11.15, y: 20.74))
        bezier3Path.addLine(to: CGPoint(x: 11.18, y: 20.74))
        bezier3Path.addLine(to: CGPoint(x: 12.18, y: 19.74))
        bezier3Path.addLine(to: CGPoint(x: 12.17, y: 19.73))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 13.52))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 13.55))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 12.5))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 12.47))
        bezier3Path.addLine(to: CGPoint(x: 27.3, y: 4.59))
        bezier3Path.addLine(to: CGPoint(x: 27.3, y: 4.59))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: 6.83, y: 19.69))
        bezier3Path.addLine(to: CGPoint(x: 6.83, y: 12.35))
        bezier3Path.addLine(to: CGPoint(x: 12.1, y: 12.35))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 7.35))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 11.3))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 12.04))
        bezier3Path.addLine(to: CGPoint(x: 10.72, y: 19.69))
        bezier3Path.addLine(to: CGPoint(x: 6.83, y: 19.69))
        bezier3Path.addLine(to: CGPoint(x: 6.83, y: 19.69))
        bezier3Path.close()
        bezier3Path.move(to: CGPoint(x: 18.37, y: 19.69))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 19.69))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 24.59))
        bezier3Path.addLine(to: CGPoint(x: 13.01, y: 20.39))
        bezier3Path.addLine(to: CGPoint(x: 12.27, y: 21.14))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 26.75))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 20.74))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 20.74))
        bezier3Path.addLine(to: CGPoint(x: 19.42, y: 13.98))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 15.03))
        bezier3Path.addLine(to: CGPoint(x: 18.37, y: 19.69))
        bezier3Path.close()
        borderColor.setFill()
        bezier3Path.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawSoundsOn(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32), resizing: ResizingBehavior = .aspectFit, borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 32, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 32, y: resizedFrame.height / 32)


        //// Bezier 5 Drawing
        let bezier5Path = UIBezierPath()
        bezier5Path.move(to: CGPoint(x: 14.63, y: 5.27))
        bezier5Path.addLine(to: CGPoint(x: 6.95, y: 11.4))
        bezier5Path.addLine(to: CGPoint(x: 1, y: 11.4))
        bezier5Path.addLine(to: CGPoint(x: 1, y: 16.14))
        bezier5Path.addLine(to: CGPoint(x: 1, y: 16.15))
        bezier5Path.addLine(to: CGPoint(x: 1, y: 16.15))
        bezier5Path.addLine(to: CGPoint(x: 1, y: 20.84))
        bezier5Path.addLine(to: CGPoint(x: 6.98, y: 20.84))
        bezier5Path.addLine(to: CGPoint(x: 14.64, y: 26.85))
        bezier5Path.addLine(to: CGPoint(x: 14.64, y: 20.84))
        bezier5Path.addLine(to: CGPoint(x: 14.64, y: 20.84))
        bezier5Path.addLine(to: CGPoint(x: 14.64, y: 11.4))
        bezier5Path.addLine(to: CGPoint(x: 14.64, y: 11.4))
        bezier5Path.addLine(to: CGPoint(x: 14.64, y: 5.27))
        bezier5Path.addLine(to: CGPoint(x: 14.63, y: 5.27))
        bezier5Path.close()
        bezier5Path.move(to: CGPoint(x: 13.59, y: 19.79))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 19.79))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 24.69))
        bezier5Path.addLine(to: CGPoint(x: 7.34, y: 19.79))
        bezier5Path.addLine(to: CGPoint(x: 2.05, y: 19.79))
        bezier5Path.addLine(to: CGPoint(x: 2.05, y: 12.45))
        bezier5Path.addLine(to: CGPoint(x: 7.32, y: 12.45))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 7.45))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 11.4))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 12.45))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 19.79))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 19.79))
        bezier5Path.addLine(to: CGPoint(x: 13.59, y: 19.79))
        bezier5Path.close()
        bezier5Path.move(to: CGPoint(x: 17.09, y: 10.73))
        bezier5Path.addCurve(to: CGPoint(x: 18.83, y: 15.97), controlPoint1: CGPoint(x: 18.23, y: 12.25), controlPoint2: CGPoint(x: 18.83, y: 14.06))
        bezier5Path.addCurve(to: CGPoint(x: 17.02, y: 21.3), controlPoint1: CGPoint(x: 18.83, y: 17.92), controlPoint2: CGPoint(x: 18.21, y: 19.76))
        bezier5Path.addLine(to: CGPoint(x: 17.85, y: 21.94))
        bezier5Path.addCurve(to: CGPoint(x: 19.88, y: 15.97), controlPoint1: CGPoint(x: 19.18, y: 20.22), controlPoint2: CGPoint(x: 19.88, y: 18.15))
        bezier5Path.addCurve(to: CGPoint(x: 17.93, y: 10.1), controlPoint1: CGPoint(x: 19.88, y: 13.83), controlPoint2: CGPoint(x: 19.2, y: 11.8))
        bezier5Path.addLine(to: CGPoint(x: 17.09, y: 10.73))
        bezier5Path.close()
        bezier5Path.move(to: CGPoint(x: 21.31, y: 6.93))
        bezier5Path.addLine(to: CGPoint(x: 20.5, y: 7.59))
        bezier5Path.addCurve(to: CGPoint(x: 23.56, y: 16.11), controlPoint1: CGPoint(x: 22.47, y: 9.98), controlPoint2: CGPoint(x: 23.56, y: 13))
        bezier5Path.addCurve(to: CGPoint(x: 20.64, y: 24.45), controlPoint1: CGPoint(x: 23.56, y: 19.17), controlPoint2: CGPoint(x: 22.55, y: 22.06))
        bezier5Path.addLine(to: CGPoint(x: 21.47, y: 25.1))
        bezier5Path.addCurve(to: CGPoint(x: 24.61, y: 16.11), controlPoint1: CGPoint(x: 23.52, y: 22.52), controlPoint2: CGPoint(x: 24.61, y: 19.41))
        bezier5Path.addCurve(to: CGPoint(x: 21.31, y: 6.93), controlPoint1: CGPoint(x: 24.61, y: 12.76), controlPoint2: CGPoint(x: 23.44, y: 9.5))
        bezier5Path.close()
        bezier5Path.move(to: CGPoint(x: 24.58, y: 3.52))
        bezier5Path.addLine(to: CGPoint(x: 23.79, y: 4.21))
        bezier5Path.addCurve(to: CGPoint(x: 28.28, y: 16.11), controlPoint1: CGPoint(x: 26.68, y: 7.5), controlPoint2: CGPoint(x: 28.28, y: 11.72))
        bezier5Path.addCurve(to: CGPoint(x: 23.95, y: 27.83), controlPoint1: CGPoint(x: 28.28, y: 20.41), controlPoint2: CGPoint(x: 26.74, y: 24.57))
        bezier5Path.addLine(to: CGPoint(x: 24.74, y: 28.51))
        bezier5Path.addCurve(to: CGPoint(x: 29.33, y: 16.11), controlPoint1: CGPoint(x: 27.7, y: 25.06), controlPoint2: CGPoint(x: 29.33, y: 20.66))
        bezier5Path.addCurve(to: CGPoint(x: 24.58, y: 3.52), controlPoint1: CGPoint(x: 29.33, y: 11.47), controlPoint2: CGPoint(x: 27.64, y: 7))
        bezier5Path.close()
        borderColor.setFill()
        bezier5Path.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawInformation(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32), resizing: ResizingBehavior = .aspectFit, borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 32, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 32, y: resizedFrame.height / 32)


        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 16, y: 2.67))
        bezierPath.addCurve(to: CGPoint(x: 2.67, y: 16), controlPoint1: CGPoint(x: 8.64, y: 2.67), controlPoint2: CGPoint(x: 2.67, y: 8.64))
        bezierPath.addCurve(to: CGPoint(x: 16, y: 29.33), controlPoint1: CGPoint(x: 2.67, y: 23.36), controlPoint2: CGPoint(x: 8.64, y: 29.33))
        bezierPath.addCurve(to: CGPoint(x: 29.33, y: 16), controlPoint1: CGPoint(x: 23.36, y: 29.33), controlPoint2: CGPoint(x: 29.33, y: 23.36))
        bezierPath.addCurve(to: CGPoint(x: 16, y: 2.67), controlPoint1: CGPoint(x: 29.33, y: 8.64), controlPoint2: CGPoint(x: 23.36, y: 2.67))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 16.07, y: 7.96))
        bezierPath.addCurve(to: CGPoint(x: 17.67, y: 9.56), controlPoint1: CGPoint(x: 16.95, y: 7.96), controlPoint2: CGPoint(x: 17.67, y: 8.67))
        bezierPath.addCurve(to: CGPoint(x: 16.07, y: 11.16), controlPoint1: CGPoint(x: 17.67, y: 10.44), controlPoint2: CGPoint(x: 16.95, y: 11.16))
        bezierPath.addCurve(to: CGPoint(x: 14.47, y: 9.56), controlPoint1: CGPoint(x: 15.18, y: 11.16), controlPoint2: CGPoint(x: 14.47, y: 10.44))
        bezierPath.addCurve(to: CGPoint(x: 16.07, y: 7.96), controlPoint1: CGPoint(x: 14.47, y: 8.67), controlPoint2: CGPoint(x: 15.18, y: 7.96))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 18.22, y: 23.42))
        bezierPath.addLine(to: CGPoint(x: 13.95, y: 23.42))
        bezierPath.addLine(to: CGPoint(x: 13.95, y: 22.35))
        bezierPath.addLine(to: CGPoint(x: 15.02, y: 22.35))
        bezierPath.addLine(to: CGPoint(x: 15.02, y: 13.29))
        bezierPath.addLine(to: CGPoint(x: 13.95, y: 13.29))
        bezierPath.addLine(to: CGPoint(x: 13.95, y: 12.22))
        bezierPath.addLine(to: CGPoint(x: 17.15, y: 12.22))
        bezierPath.addLine(to: CGPoint(x: 17.15, y: 22.35))
        bezierPath.addLine(to: CGPoint(x: 18.22, y: 22.35))
        bezierPath.addLine(to: CGPoint(x: 18.22, y: 23.42))
        bezierPath.close()
        borderColor.setFill()
        bezierPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawFeedbackOn(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 32, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 32, y: resizedFrame.height / 32)


        //// Color Declarations
        let fillColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 23.09, y: 1.61))
        bezierPath.addLine(to: CGPoint(x: 8.91, y: 1.61))
        bezierPath.addCurve(to: CGPoint(x: 7.47, y: 3.05), controlPoint1: CGPoint(x: 8.12, y: 1.61), controlPoint2: CGPoint(x: 7.47, y: 2.25))
        bezierPath.addLine(to: CGPoint(x: 7.47, y: 28.95))
        bezierPath.addCurve(to: CGPoint(x: 8.91, y: 30.39), controlPoint1: CGPoint(x: 7.47, y: 29.75), controlPoint2: CGPoint(x: 8.12, y: 30.39))
        bezierPath.addLine(to: CGPoint(x: 23.09, y: 30.39))
        bezierPath.addCurve(to: CGPoint(x: 24.53, y: 28.95), controlPoint1: CGPoint(x: 23.88, y: 30.39), controlPoint2: CGPoint(x: 24.53, y: 29.75))
        bezierPath.addLine(to: CGPoint(x: 24.53, y: 3.05))
        bezierPath.addCurve(to: CGPoint(x: 23.09, y: 1.61), controlPoint1: CGPoint(x: 24.53, y: 2.25), controlPoint2: CGPoint(x: 23.88, y: 1.61))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 23.46, y: 28.95))
        bezierPath.addCurve(to: CGPoint(x: 23.09, y: 29.33), controlPoint1: CGPoint(x: 23.46, y: 29.16), controlPoint2: CGPoint(x: 23.29, y: 29.33))
        bezierPath.addLine(to: CGPoint(x: 8.91, y: 29.33))
        bezierPath.addCurve(to: CGPoint(x: 8.54, y: 28.95), controlPoint1: CGPoint(x: 8.71, y: 29.33), controlPoint2: CGPoint(x: 8.54, y: 29.16))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 24))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 24))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 28.95))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 28.95))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 23.46, y: 22.93))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 22.93))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 5.89))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 5.89))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 22.93))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 23.46, y: 4.83))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 4.83))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 3.05))
        bezierPath.addCurve(to: CGPoint(x: 8.91, y: 2.67), controlPoint1: CGPoint(x: 8.54, y: 2.84), controlPoint2: CGPoint(x: 8.7, y: 2.67))
        bezierPath.addLine(to: CGPoint(x: 23.09, y: 2.67))
        bezierPath.addCurve(to: CGPoint(x: 23.46, y: 3.05), controlPoint1: CGPoint(x: 23.29, y: 2.67), controlPoint2: CGPoint(x: 23.46, y: 2.84))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 4.83))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 4.83))
        bezierPath.close()
        fillColor.setFill()
        bezierPath.fill()


        //// Rectangle 2 Drawing
        let rectangle2Path = UIBezierPath(rect: CGRect(x: 26, y: 6, width: 1.05, height: 20))
        fillColor.setFill()
        rectangle2Path.fill()


        //// Rectangle 3 Drawing
        let rectangle3Path = UIBezierPath(rect: CGRect(x: 28, y: 9, width: 1.05, height: 14))
        fillColor.setFill()
        rectangle3Path.fill()


        //// Rectangle 4 Drawing
        let rectangle4Path = UIBezierPath(rect: CGRect(x: 30, y: 12, width: 1.05, height: 8))
        fillColor.setFill()
        rectangle4Path.fill()


        //// Rectangle 5 Drawing
        let rectangle5Path = UIBezierPath(rect: CGRect(x: 4.95, y: 6, width: 1.05, height: 20))
        fillColor.setFill()
        rectangle5Path.fill()


        //// Rectangle 6 Drawing
        let rectangle6Path = UIBezierPath(rect: CGRect(x: 2.95, y: 9, width: 1.05, height: 14))
        fillColor.setFill()
        rectangle6Path.fill()


        //// Rectangle 7 Drawing
        let rectangle7Path = UIBezierPath(rect: CGRect(x: 0.95, y: 12, width: 1.05, height: 8))
        fillColor.setFill()
        rectangle7Path.fill()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 14, y: 25, width: 3.5, height: 3.5))
        UIColor.black.setFill()
        ovalPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawFeedbackOff(frame targetFrame: CGRect = CGRect(x: 0, y: 0, width: 32, height: 32), resizing: ResizingBehavior = .aspectFit) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!
        
        //// Resize to Target Frame
        context.saveGState()
        let resizedFrame: CGRect = resizing.apply(rect: CGRect(x: 0, y: 0, width: 32, height: 32), target: targetFrame)
        context.translateBy(x: resizedFrame.minX, y: resizedFrame.minY)
        context.scaleBy(x: resizedFrame.width / 32, y: resizedFrame.height / 32)


        //// Color Declarations
        let fillColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: 23.09, y: 2.67))
        bezierPath.addLine(to: CGPoint(x: 8.91, y: 2.67))
        bezierPath.addCurve(to: CGPoint(x: 8.54, y: 3.05), controlPoint1: CGPoint(x: 8.7, y: 2.67), controlPoint2: CGPoint(x: 8.54, y: 2.84))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 4.83))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 4.83))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 3.05))
        bezierPath.addCurve(to: CGPoint(x: 23.09, y: 2.67), controlPoint1: CGPoint(x: 23.46, y: 2.84), controlPoint2: CGPoint(x: 23.29, y: 2.67))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 23.46, y: 5.89))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 5.89))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 22.93))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 22.93))
        bezierPath.addLine(to: CGPoint(x: 23.46, y: 5.89))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 23.47, y: 24))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 24))
        bezierPath.addLine(to: CGPoint(x: 8.54, y: 28.95))
        bezierPath.addCurve(to: CGPoint(x: 8.91, y: 29.33), controlPoint1: CGPoint(x: 8.54, y: 29.16), controlPoint2: CGPoint(x: 8.71, y: 29.33))
        bezierPath.addLine(to: CGPoint(x: 23.09, y: 29.33))
        bezierPath.addCurve(to: CGPoint(x: 23.46, y: 28.95), controlPoint1: CGPoint(x: 23.3, y: 29.33), controlPoint2: CGPoint(x: 23.46, y: 29.16))
        bezierPath.addCurve(to: CGPoint(x: 23.47, y: 24), controlPoint1: CGPoint(x: 23.47, y: 28.95), controlPoint2: CGPoint(x: 23.47, y: 24))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: 24.53, y: 3.05))
        bezierPath.addLine(to: CGPoint(x: 24.53, y: 28.95))
        bezierPath.addCurve(to: CGPoint(x: 23.09, y: 30.4), controlPoint1: CGPoint(x: 24.53, y: 29.75), controlPoint2: CGPoint(x: 23.88, y: 30.4))
        bezierPath.addLine(to: CGPoint(x: 8.91, y: 30.4))
        bezierPath.addCurve(to: CGPoint(x: 7.47, y: 28.95), controlPoint1: CGPoint(x: 8.12, y: 30.4), controlPoint2: CGPoint(x: 7.47, y: 29.75))
        bezierPath.addLine(to: CGPoint(x: 7.47, y: 3.05))
        bezierPath.addCurve(to: CGPoint(x: 8.91, y: 1.61), controlPoint1: CGPoint(x: 7.47, y: 2.25), controlPoint2: CGPoint(x: 8.12, y: 1.61))
        bezierPath.addLine(to: CGPoint(x: 23.09, y: 1.61))
        bezierPath.addCurve(to: CGPoint(x: 24.53, y: 3.05), controlPoint1: CGPoint(x: 23.88, y: 1.61), controlPoint2: CGPoint(x: 24.53, y: 2.25))
        bezierPath.close()
        fillColor.setFill()
        bezierPath.fill()


        //// Oval Drawing
        let ovalPath = UIBezierPath(ovalIn: CGRect(x: 14, y: 25, width: 3.5, height: 3.5))
        UIColor.black.setFill()
        ovalPath.fill()
        
        context.restoreGState()

    }

    @objc dynamic public class func drawPalmOilLogo(frame: CGRect = CGRect(x: 0, y: 503, width: 208, height: 308), borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) {
        //// General Declarations
        // This non-generic function dramatically improves compilation times of complex expressions.
        func fastFloor(_ x: CGFloat) -> CGFloat { return floor(x) }


        //// Subframes
        let layer_1: CGRect = CGRect(x: frame.minX + fastFloor(frame.width * 0.05134 - 0.18) + 0.68, y: frame.minY + 25.36, width: fastFloor(frame.width * 0.93575 - 0.14) - fastFloor(frame.width * 0.05134 - 0.18) - 0.04, height: frame.height - 44.96)


        //// Layer_1
        //// Bezier Drawing
        let bezierPath = UIBezierPath()
        bezierPath.move(to: CGPoint(x: layer_1.minX + 0.30319 * layer_1.width, y: layer_1.minY + 0.00000 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.44803 * layer_1.width, y: layer_1.minY + 0.01759 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.35237 * layer_1.width, y: layer_1.minY + 0.00100 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.40180 * layer_1.width, y: layer_1.minY + 0.00665 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.21702 * layer_1.width, y: layer_1.minY + 0.08841 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.34207 * layer_1.width, y: layer_1.minY + 0.01759 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.21702 * layer_1.width, y: layer_1.minY + 0.08841 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.57895 * layer_1.width, y: layer_1.minY + 0.14631 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.52618 * layer_1.width, y: layer_1.minY + 0.04977 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.57895 * layer_1.width, y: layer_1.minY + 0.14631 * layer_1.height))
        bezierPath.addLine(to: CGPoint(x: layer_1.minX + 0.44803 * layer_1.width, y: layer_1.minY + 0.12701 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.27735 * layer_1.width, y: layer_1.minY + 0.14617 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.35811 * layer_1.width, y: layer_1.minY + 0.11403 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.30588 * layer_1.width, y: layer_1.minY + 0.12428 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.55601 * layer_1.width, y: layer_1.minY + 0.39848 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.36266 * layer_1.width, y: layer_1.minY + 0.17289 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.48150 * layer_1.width, y: layer_1.minY + 0.23860 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.77066 * layer_1.width, y: layer_1.minY + 0.22062 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.61772 * layer_1.width, y: layer_1.minY + 0.28845 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.70591 * layer_1.width, y: layer_1.minY + 0.24093 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.62960 * layer_1.width, y: layer_1.minY + 0.20477 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.74704 * layer_1.width, y: layer_1.minY + 0.20248 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.70392 * layer_1.width, y: layer_1.minY + 0.19405 * layer_1.height))
        bezierPath.addLine(to: CGPoint(x: layer_1.minX + 0.52135 * layer_1.width, y: layer_1.minY + 0.22074 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.82055 * layer_1.width, y: layer_1.minY + 0.17285 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.52135 * layer_1.width, y: layer_1.minY + 0.22074 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.56496 * layer_1.width, y: layer_1.minY + 0.14092 * layer_1.height))
        bezierPath.addLine(to: CGPoint(x: layer_1.minX + 0.91403 * layer_1.width, y: layer_1.minY + 0.20477 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.91404 * layer_1.width, y: layer_1.minY + 0.39632 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.91403 * layer_1.width, y: layer_1.minY + 0.20477 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 1.10746 * layer_1.width, y: layer_1.minY + 0.34305 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.85920 * layer_1.width, y: layer_1.minY + 0.25265 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.91404 * layer_1.width, y: layer_1.minY + 0.39632 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.95592 * layer_1.width, y: layer_1.minY + 0.28260 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.74914 * layer_1.width, y: layer_1.minY + 0.39632 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.85927 * layer_1.width, y: layer_1.minY + 0.29868 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.84665 * layer_1.width, y: layer_1.minY + 0.39441 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.74914 * layer_1.width, y: layer_1.minY + 0.39632 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.74913 * layer_1.width, y: layer_1.minY + 0.39632 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.74914 * layer_1.width, y: layer_1.minY + 0.39632 * layer_1.height))
        bezierPath.addLine(to: CGPoint(x: layer_1.minX + 0.74914 * layer_1.width, y: layer_1.minY + 0.39632 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.78783 * layer_1.width, y: layer_1.minY + 0.24075 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.77872 * layer_1.width, y: layer_1.minY + 0.35170 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.80919 * layer_1.width, y: layer_1.minY + 0.28817 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.62882 * layer_1.width, y: layer_1.minY + 0.46623 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.67053 * layer_1.width, y: layer_1.minY + 0.31260 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.63533 * layer_1.width, y: layer_1.minY + 0.39911 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.60050 * layer_1.width, y: layer_1.minY + 0.53484 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.62636 * layer_1.width, y: layer_1.minY + 0.49162 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.61420 * layer_1.width, y: layer_1.minY + 0.51542 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.80738 * layer_1.width, y: layer_1.minY + 0.83729 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.67105 * layer_1.width, y: layer_1.minY + 0.66650 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.80738 * layer_1.width, y: layer_1.minY + 0.71727 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.54917 * layer_1.width, y: layer_1.minY + 1.00000 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.80738 * layer_1.width, y: layer_1.minY + 0.92714 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.68919 * layer_1.width, y: layer_1.minY + 1.00000 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.29096 * layer_1.width, y: layer_1.minY + 0.83729 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.40915 * layer_1.width, y: layer_1.minY + 1.00000 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.29096 * layer_1.width, y: layer_1.minY + 0.92714 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.48906 * layer_1.width, y: layer_1.minY + 0.55009 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.29096 * layer_1.width, y: layer_1.minY + 0.72202 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.41664 * layer_1.width, y: layer_1.minY + 0.67062 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.45022 * layer_1.width, y: layer_1.minY + 0.46065 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.47094 * layer_1.width, y: layer_1.minY + 0.52773 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.45165 * layer_1.width, y: layer_1.minY + 0.49592 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.25669 * layer_1.width, y: layer_1.minY + 0.17055 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.44684 * layer_1.width, y: layer_1.minY + 0.37747 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.53272 * layer_1.width, y: layer_1.minY + 0.33962 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.26407 * layer_1.width, y: layer_1.minY + 0.28437 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.23942 * layer_1.width, y: layer_1.minY + 0.20759 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.24957 * layer_1.width, y: layer_1.minY + 0.24765 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.30346 * layer_1.width, y: layer_1.minY + 0.35874 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.27405 * layer_1.width, y: layer_1.minY + 0.30964 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.28686 * layer_1.width, y: layer_1.minY + 0.33487 * layer_1.height))
        bezierPath.addLine(to: CGPoint(x: layer_1.minX + 0.30346 * layer_1.width, y: layer_1.minY + 0.35874 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.30346 * layer_1.width, y: layer_1.minY + 0.35874 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.30347 * layer_1.width, y: layer_1.minY + 0.35875 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.30347 * layer_1.width, y: layer_1.minY + 0.35875 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.17036 * layer_1.width, y: layer_1.minY + 0.18494 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.18677 * layer_1.width, y: layer_1.minY + 0.35667 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.16905 * layer_1.width, y: layer_1.minY + 0.24006 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.10395 * layer_1.width, y: layer_1.minY + 0.35874 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.05339 * layer_1.width, y: layer_1.minY + 0.22118 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.10395 * layer_1.width, y: layer_1.minY + 0.35874 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.10395 * layer_1.width, y: layer_1.minY + 0.12701 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + -0.12994 * layer_1.width, y: layer_1.minY + 0.29429 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.10395 * layer_1.width, y: layer_1.minY + 0.12701 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.18095 * layer_1.width, y: layer_1.minY + 0.01933 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.10552 * layer_1.width, y: layer_1.minY + 0.08632 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.12487 * layer_1.width, y: layer_1.minY + 0.04288 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.30319 * layer_1.width, y: layer_1.minY + 0.00000 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.21738 * layer_1.width, y: layer_1.minY + 0.00402 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.26052 * layer_1.width, y: layer_1.minY + 0.00028 * layer_1.height))
        bezierPath.close()
        bezierPath.move(to: CGPoint(x: layer_1.minX + 0.50298 * layer_1.width, y: layer_1.minY + 0.65886 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.49338 * layer_1.width, y: layer_1.minY + 0.66250 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.49886 * layer_1.width, y: layer_1.minY + 0.65915 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.49574 * layer_1.width, y: layer_1.minY + 0.66037 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.45665 * layer_1.width, y: layer_1.minY + 0.69635 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.48298 * layer_1.width, y: layer_1.minY + 0.67354 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.47019 * layer_1.width, y: layer_1.minY + 0.68463 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.36438 * layer_1.width, y: layer_1.minY + 0.84123 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.41340 * layer_1.width, y: layer_1.minY + 0.73380 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.36438 * layer_1.width, y: layer_1.minY + 0.77625 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.41770 * layer_1.width, y: layer_1.minY + 0.87556 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.36438 * layer_1.width, y: layer_1.minY + 0.86016 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.38830 * layer_1.width, y: layer_1.minY + 0.87556 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.47104 * layer_1.width, y: layer_1.minY + 0.83520 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.44349 * layer_1.width, y: layer_1.minY + 0.87556 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.47104 * layer_1.width, y: layer_1.minY + 0.86497 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.51052 * layer_1.width, y: layer_1.minY + 0.69072 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.47104 * layer_1.width, y: layer_1.minY + 0.78019 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.49201 * layer_1.width, y: layer_1.minY + 0.73266 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.51921 * layer_1.width, y: layer_1.minY + 0.67078 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.51354 * layer_1.width, y: layer_1.minY + 0.68387 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.51647 * layer_1.width, y: layer_1.minY + 0.67723 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.51673 * layer_1.width, y: layer_1.minY + 0.66267 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.52039 * layer_1.width, y: layer_1.minY + 0.66801 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.51948 * layer_1.width, y: layer_1.minY + 0.66505 * layer_1.height))
        bezierPath.addCurve(to: CGPoint(x: layer_1.minX + 0.50298 * layer_1.width, y: layer_1.minY + 0.65886 * layer_1.height), controlPoint1: CGPoint(x: layer_1.minX + 0.51241 * layer_1.width, y: layer_1.minY + 0.65932 * layer_1.height), controlPoint2: CGPoint(x: layer_1.minX + 0.50940 * layer_1.width, y: layer_1.minY + 0.65915 * layer_1.height))
        bezierPath.close()
        borderColor.setFill()
        bezierPath.fill()
    }

    @objc dynamic public class func drawShadow(frame: CGRect = CGRect(x: 0, y: 69, width: 240, height: 25)) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()!


        //// Gradient Declarations
        let gradient = CGGradient(colorsSpace: nil, colors: [UIColor.clear.cgColor, UIColor.clear.blended(withFraction: 0.5, of: UIColor.black).cgColor, UIColor.black.cgColor] as CFArray, locations: [0, 0.46, 0.68])!

        //// Oval Drawing
        let ovalRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height + 25)
        let ovalPath = UIBezierPath(ovalIn: ovalRect)
        context.saveGState()
        ovalPath.addClip()
        context.drawLinearGradient(gradient,
            start: CGPoint(x: ovalRect.midX, y: ovalRect.minY),
            end: CGPoint(x: ovalRect.midX, y: ovalRect.maxY),
            options: [])
        context.restoreGState()
    }

    //// Generated Images

    @objc dynamic public class func imageOfFlashlightOff(borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 32, height: 32), false, 0)
            PalmOilGlyphs.drawFlashlightOff(borderColor: borderColor)

        let imageOfFlashlightOff = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfFlashlightOff
    }

    @objc dynamic public class func imageOfFlashlightOn(borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 32, height: 32), false, 0)
            PalmOilGlyphs.drawFlashlightOn(borderColor: borderColor)

        let imageOfFlashlightOn = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfFlashlightOn
    }

    @objc dynamic public class func imageOfSoundsOff(borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 32), false, 0)
            PalmOilGlyphs.drawSoundsOff(borderColor: borderColor)

        let imageOfSoundsOff = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfSoundsOff
    }

    @objc dynamic public class func imageOfSoundsOn(borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 32, height: 32), false, 0)
            PalmOilGlyphs.drawSoundsOn(borderColor: borderColor)

        let imageOfSoundsOn = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfSoundsOn
    }

    @objc dynamic public class func imageOfInformation(borderColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)) -> UIImage {
        UIGraphicsBeginImageContextWithOptions(CGSize(width: 32, height: 32), false, 0)
            PalmOilGlyphs.drawInformation(borderColor: borderColor)

        let imageOfInformation = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return imageOfInformation
    }

    @objc dynamic public class var imageOfFeedbackOn: UIImage {
        if Cache.imageOfFeedbackOn != nil {
            return Cache.imageOfFeedbackOn!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 32, height: 32), false, 0)
            PalmOilGlyphs.drawFeedbackOn()

        Cache.imageOfFeedbackOn = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfFeedbackOn!
    }

    @objc dynamic public class var imageOfFeedbackOff: UIImage {
        if Cache.imageOfFeedbackOff != nil {
            return Cache.imageOfFeedbackOff!
        }

        UIGraphicsBeginImageContextWithOptions(CGSize(width: 32, height: 32), false, 0)
            PalmOilGlyphs.drawFeedbackOff()

        Cache.imageOfFeedbackOff = UIGraphicsGetImageFromCurrentImageContext()!
        UIGraphicsEndImageContext()

        return Cache.imageOfFeedbackOff!
    }

    //// Customization Infrastructure

    @IBOutlet @objc dynamic var feedbackOnTargets: [AnyObject]! {
        get { return Cache.feedbackOnTargets }
        set {
            Cache.feedbackOnTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: PalmOilGlyphs.imageOfFeedbackOn)
            }
        }
    }

    @IBOutlet @objc dynamic var feedbackOffTargets: [AnyObject]! {
        get { return Cache.feedbackOffTargets }
        set {
            Cache.feedbackOffTargets = newValue
            for target: AnyObject in newValue {
                let _ = target.perform(NSSelectorFromString("setImage:"), with: PalmOilGlyphs.imageOfFeedbackOff)
            }
        }
    }




    @objc(PalmOilGlyphsResizingBehavior)
    public enum ResizingBehavior: Int {
        case aspectFit /// The content is proportionally resized to fit into the target rectangle.
        case aspectFill /// The content is proportionally resized to completely fill the target rectangle.
        case stretch /// The content is stretched to match the entire target rectangle.
        case center /// The content is centered in the target rectangle, but it is NOT resized.

        public func apply(rect: CGRect, target: CGRect) -> CGRect {
            if rect == target || target == CGRect.zero {
                return rect
            }

            var scales = CGSize.zero
            scales.width = abs(target.width / rect.width)
            scales.height = abs(target.height / rect.height)

            switch self {
                case .aspectFit:
                    scales.width = min(scales.width, scales.height)
                    scales.height = scales.width
                case .aspectFill:
                    scales.width = max(scales.width, scales.height)
                    scales.height = scales.width
                case .stretch:
                    break
                case .center:
                    scales.width = 1
                    scales.height = 1
            }

            var result = rect.standardized
            result.size.width *= scales.width
            result.size.height *= scales.height
            result.origin.x = target.minX + (target.width - result.width) / 2
            result.origin.y = target.minY + (target.height - result.height) / 2
            return result
        }
    }
}



private extension UIColor {
    func withHue(_ newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func withSaturation(_ newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1, brightness: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func withBrightness(_ newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, alpha: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func withAlpha(_ newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1, saturation: CGFloat = 1, brightness: CGFloat = 1
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func highlight(withLevel highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func shadow(withLevel shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1, green: CGFloat = 1, blue: CGFloat = 1, alpha: CGFloat = 1
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
    func blended(withFraction fraction: CGFloat, of color: UIColor) -> UIColor {
        var r1: CGFloat = 1, g1: CGFloat = 1, b1: CGFloat = 1, a1: CGFloat = 1
        var r2: CGFloat = 1, g2: CGFloat = 1, b2: CGFloat = 1, a2: CGFloat = 1

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}
